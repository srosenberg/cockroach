// Command github-post parses the JSON-formatted output from a Go test session,
// as generated by either 'go test -json' or './pkg.test | go tool test2json -t',
// and posts issues for any failed tests to GitHub. If there are no failed
// tests, it assumes that there was a build error and posts the entire log to
// GitHub.
package main

import __antithesis_instrumentation__ "antithesis.com/instrumentation/wrappers"

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/cockroachdb/cockroach/pkg/cmd/internal/issues"
	"github.com/cockroachdb/cockroach/pkg/internal/codeowners"
	"github.com/cockroachdb/cockroach/pkg/internal/team"
	"github.com/cockroachdb/errors"
)

const (
	pkgEnv  = "PKG"
	unknown = "(unknown)"
)

type formatter func(context.Context, failure) (issues.IssueFormatter, issues.PostRequest)

func defaultFormatter(ctx context.Context, f failure) (issues.IssueFormatter, issues.PostRequest) {
	__antithesis_instrumentation__.Notify(40676)
	teams := getOwner(ctx, f.packageName, f.testName)
	repro := fmt.Sprintf("make stressrace TESTS=%s PKG=./pkg/%s TESTTIMEOUT=5m STRESSFLAGS='-timeout 5m' 2>&1",
		f.testName, trimPkg(f.packageName))

	var projColID int
	var mentions []string
	if len(teams) > 0 {
		__antithesis_instrumentation__.Notify(40678)
		projColID = teams[0].TriageColumnID
		for _, team := range teams {
			__antithesis_instrumentation__.Notify(40679)
			mentions = append(mentions, "@"+string(team.Name()))
		}
	} else {
		__antithesis_instrumentation__.Notify(40680)
	}
	__antithesis_instrumentation__.Notify(40677)
	return issues.UnitTestFormatter, issues.PostRequest{
		TestName:        f.testName,
		PackageName:     f.packageName,
		Message:         f.testMessage,
		Artifacts:       "/",
		HelpCommand:     issues.UnitTestHelpCommand(repro),
		MentionOnCreate: mentions,
		ProjectColumnID: projColID,
	}
}

func main() {
	__antithesis_instrumentation__.Notify(40681)
	formatterName := flag.String("formatter", "", "formatter to use to construct GitHub issues")
	flag.Parse()

	var reqFromFailure formatter
	switch *formatterName {
	case "pebble-metamorphic":
		__antithesis_instrumentation__.Notify(40684)
		reqFromFailure = formatPebbleMetamorphicIssue
	default:
		__antithesis_instrumentation__.Notify(40685)
		reqFromFailure = defaultFormatter
	}
	__antithesis_instrumentation__.Notify(40682)

	fileIssue := func(ctx context.Context, f failure) error {
		__antithesis_instrumentation__.Notify(40686)
		fmter, req := reqFromFailure(ctx, f)
		return issues.Post(ctx, fmter, req)
	}
	__antithesis_instrumentation__.Notify(40683)

	ctx := context.Background()
	if err := listFailures(ctx, os.Stdin, fileIssue); err != nil {
		__antithesis_instrumentation__.Notify(40687)
		log.Println(err)
	} else {
		__antithesis_instrumentation__.Notify(40688)
	}
}

type failure struct {
	title       string
	packageName string
	testName    string
	testMessage string
}

type testEvent struct {
	Action  string
	Package string
	Test    string
	Output  string
	Time    time.Time
	Elapsed float64
}

type scopedTest struct {
	pkg  string
	name string
}

func scoped(te testEvent) scopedTest {
	__antithesis_instrumentation__.Notify(40689)
	if te.Package == "" {
		__antithesis_instrumentation__.Notify(40691)
		return scopedTest{pkg: mustPkgFromEnv(), name: te.Test}
	} else {
		__antithesis_instrumentation__.Notify(40692)
	}
	__antithesis_instrumentation__.Notify(40690)
	return scopedTest{pkg: te.Package, name: te.Test}
}

func mustPkgFromEnv() string {
	__antithesis_instrumentation__.Notify(40693)
	packageName := os.Getenv(pkgEnv)
	if packageName == "" {
		__antithesis_instrumentation__.Notify(40695)
		panic(errors.Errorf("package name environment variable %s is not set", pkgEnv))
	} else {
		__antithesis_instrumentation__.Notify(40696)
	}
	__antithesis_instrumentation__.Notify(40694)
	return packageName
}

func maybeEnv(envKey, defaultValue string) string {
	__antithesis_instrumentation__.Notify(40697)
	v := os.Getenv(envKey)
	if v == "" {
		__antithesis_instrumentation__.Notify(40699)
		return defaultValue
	} else {
		__antithesis_instrumentation__.Notify(40700)
	}
	__antithesis_instrumentation__.Notify(40698)
	return v
}

func shortPkg() string {
	__antithesis_instrumentation__.Notify(40701)
	packageName := maybeEnv(pkgEnv, "unknown")
	return trimPkg(packageName)
}

func trimPkg(pkg string) string {
	__antithesis_instrumentation__.Notify(40702)
	return strings.TrimPrefix(pkg, issues.CockroachPkgPrefix)
}

func listFailures(
	ctx context.Context, input io.Reader, fileIssue func(context.Context, failure) error,
) error {
	__antithesis_instrumentation__.Notify(40703)

	const shortTestFilterSecs float64 = 0.5
	var timeoutMsg = "panic: test timed out after"

	var packageOutput bytes.Buffer

	outstandingOutput := make(map[scopedTest][]testEvent)
	failures := make(map[scopedTest][]testEvent)
	var slowPassEvents []testEvent
	var slowFailEvents []testEvent

	init := true

	trustTimestamps := true

	var elapsedTotalSec float64

	var timedOutCulprit scopedTest
	var timedOutEvent testEvent
	var curTestStart time.Time
	var last scopedTest
	var lastEvent testEvent
	scanner := bufio.NewScanner(input)
	for scanner.Scan() {
		__antithesis_instrumentation__.Notify(40711)
		var te testEvent
		{
			__antithesis_instrumentation__.Notify(40717)
			line := scanner.Text()
			if len(line) <= 2 || func() bool {
				__antithesis_instrumentation__.Notify(40719)
				return line[0] != '{' == true
			}() == true || func() bool {
				__antithesis_instrumentation__.Notify(40720)
				return line[len(line)-1] != '}' == true
			}() == true {
				__antithesis_instrumentation__.Notify(40721)

				continue
			} else {
				__antithesis_instrumentation__.Notify(40722)
			}
			__antithesis_instrumentation__.Notify(40718)
			if err := json.Unmarshal([]byte(line), &te); err != nil {
				__antithesis_instrumentation__.Notify(40723)
				return errors.Wrapf(err, "unable to parse %q", line)
			} else {
				__antithesis_instrumentation__.Notify(40724)
			}
		}
		__antithesis_instrumentation__.Notify(40712)
		lastEvent = te

		if te.Test != "" {
			__antithesis_instrumentation__.Notify(40725)
			init = false
		} else {
			__antithesis_instrumentation__.Notify(40726)
		}
		__antithesis_instrumentation__.Notify(40713)
		if init && func() bool {
			__antithesis_instrumentation__.Notify(40727)
			return strings.Contains(te.Output, "-exec 'stress '") == true
		}() == true {
			__antithesis_instrumentation__.Notify(40728)
			trustTimestamps = false
		} else {
			__antithesis_instrumentation__.Notify(40729)
		}
		__antithesis_instrumentation__.Notify(40714)
		if timedOutCulprit.name == "" && func() bool {
			__antithesis_instrumentation__.Notify(40730)
			return te.Elapsed > 0 == true
		}() == true {
			__antithesis_instrumentation__.Notify(40731)

			if split := strings.SplitN(te.Test, "/", 2); len(split) == 1 {
				__antithesis_instrumentation__.Notify(40732)
				elapsedTotalSec += te.Elapsed
			} else {
				__antithesis_instrumentation__.Notify(40733)
			}
		} else {
			__antithesis_instrumentation__.Notify(40734)
		}
		__antithesis_instrumentation__.Notify(40715)

		if timedOutCulprit.name == te.Test && func() bool {
			__antithesis_instrumentation__.Notify(40735)
			return te.Elapsed != 0 == true
		}() == true {
			__antithesis_instrumentation__.Notify(40736)
			te.Elapsed = timedOutEvent.Elapsed
		} else {
			__antithesis_instrumentation__.Notify(40737)
		}
		__antithesis_instrumentation__.Notify(40716)

		if len(te.Test) > 0 {
			__antithesis_instrumentation__.Notify(40738)
			switch te.Action {
			case "run":
				__antithesis_instrumentation__.Notify(40739)
				last = scoped(te)
				if trustTimestamps {
					__antithesis_instrumentation__.Notify(40747)
					curTestStart = te.Time
				} else {
					__antithesis_instrumentation__.Notify(40748)
				}
			case "output":
				__antithesis_instrumentation__.Notify(40740)
				key := scoped(te)
				outstandingOutput[key] = append(outstandingOutput[key], te)
				if strings.Contains(te.Output, timeoutMsg) {
					__antithesis_instrumentation__.Notify(40749)
					timedOutCulprit = key

					if trustTimestamps {
						__antithesis_instrumentation__.Notify(40751)
						te.Elapsed = te.Time.Sub(curTestStart).Seconds()
					} else {
						__antithesis_instrumentation__.Notify(40752)

						re := regexp.MustCompile(`panic: test timed out after (\d*(?:\.\d*)?)(.)`)
						matches := re.FindStringSubmatch(te.Output)
						if matches == nil {
							__antithesis_instrumentation__.Notify(40753)
							log.Printf("failed to parse timeout message: %s", te.Output)
							te.Elapsed = -1
						} else {
							__antithesis_instrumentation__.Notify(40754)
							dur, err := strconv.ParseFloat(matches[1], 64)
							if err != nil {
								__antithesis_instrumentation__.Notify(40757)
								log.Fatal(err)
							} else {
								__antithesis_instrumentation__.Notify(40758)
							}
							__antithesis_instrumentation__.Notify(40755)
							if matches[2] == "m" {
								__antithesis_instrumentation__.Notify(40759)

								dur *= 60
							} else {
								__antithesis_instrumentation__.Notify(40760)
								if matches[2] != "s" {
									__antithesis_instrumentation__.Notify(40761)
									log.Fatalf("unexpected time unit in: %s", te.Output)
								} else {
									__antithesis_instrumentation__.Notify(40762)
								}
							}
							__antithesis_instrumentation__.Notify(40756)
							te.Elapsed = dur - elapsedTotalSec
						}
					}
					__antithesis_instrumentation__.Notify(40750)
					timedOutEvent = te
				} else {
					__antithesis_instrumentation__.Notify(40763)
				}
			case "pass", "skip":
				__antithesis_instrumentation__.Notify(40741)
				if timedOutCulprit.name != "" {
					__antithesis_instrumentation__.Notify(40764)

					timedOutCulprit = scopedTest{}
				} else {
					__antithesis_instrumentation__.Notify(40765)
				}
				__antithesis_instrumentation__.Notify(40742)
				delete(outstandingOutput, scoped(te))
				if te.Elapsed > shortTestFilterSecs {
					__antithesis_instrumentation__.Notify(40766)

					if !strings.Contains(te.Test, "/") {
						__antithesis_instrumentation__.Notify(40767)
						slowPassEvents = append(slowPassEvents, te)
					} else {
						__antithesis_instrumentation__.Notify(40768)
					}
				} else {
					__antithesis_instrumentation__.Notify(40769)
				}
			case "fail":
				__antithesis_instrumentation__.Notify(40743)
				key := scoped(te)

				if !strings.Contains(te.Test, "/") || func() bool {
					__antithesis_instrumentation__.Notify(40770)
					return timedOutCulprit == key == true
				}() == true {
					__antithesis_instrumentation__.Notify(40771)
					slowFailEvents = append(slowFailEvents, te)
				} else {
					__antithesis_instrumentation__.Notify(40772)
				}
				__antithesis_instrumentation__.Notify(40744)

				if timedOutCulprit != key {
					__antithesis_instrumentation__.Notify(40773)
					failures[key] = outstandingOutput[key]
				} else {
					__antithesis_instrumentation__.Notify(40774)
				}
				__antithesis_instrumentation__.Notify(40745)
				delete(outstandingOutput, key)
			default:
				__antithesis_instrumentation__.Notify(40746)
			}
		} else {
			__antithesis_instrumentation__.Notify(40775)
			if te.Action == "output" {
				__antithesis_instrumentation__.Notify(40776)

				packageOutput.WriteString(te.Output)
			} else {
				__antithesis_instrumentation__.Notify(40777)
			}
		}
	}
	__antithesis_instrumentation__.Notify(40704)

	if timedOutCulprit.name != "" {
		__antithesis_instrumentation__.Notify(40778)
		if _, ok := outstandingOutput[timedOutCulprit]; ok {
			__antithesis_instrumentation__.Notify(40779)
			slowFailEvents = append(slowFailEvents, timedOutEvent)
			delete(outstandingOutput, timedOutCulprit)
		} else {
			__antithesis_instrumentation__.Notify(40780)
		}
	} else {
		__antithesis_instrumentation__.Notify(40781)

		if _, ok := outstandingOutput[last]; ok {
			__antithesis_instrumentation__.Notify(40782)
			log.Printf("found outstanding output. Considering last test failed: %s", last)
			failures[last] = outstandingOutput[last]
		} else {
			__antithesis_instrumentation__.Notify(40783)
		}
	}
	__antithesis_instrumentation__.Notify(40705)

	if lastEvent.Action == "fail" && func() bool {
		__antithesis_instrumentation__.Notify(40784)
		return len(failures) == 0 == true
	}() == true && func() bool {
		__antithesis_instrumentation__.Notify(40785)
		return timedOutCulprit.name == "" == true
	}() == true {
		__antithesis_instrumentation__.Notify(40786)

		err := fileIssue(ctx, failure{
			title:       fmt.Sprintf("%s: package failed", shortPkg()),
			packageName: maybeEnv(pkgEnv, "unknown"),
			testName:    unknown,
			testMessage: packageOutput.String(),
		})
		if err != nil {
			__antithesis_instrumentation__.Notify(40787)
			return errors.Wrap(err, "failed to post issue")
		} else {
			__antithesis_instrumentation__.Notify(40788)
		}
	} else {
		__antithesis_instrumentation__.Notify(40789)
		for test, testEvents := range failures {
			__antithesis_instrumentation__.Notify(40793)
			if split := strings.SplitN(test.name, "/", 2); len(split) == 2 {
				__antithesis_instrumentation__.Notify(40794)
				parentTest, subTest := scopedTest{pkg: test.pkg, name: split[0]}, scopedTest{pkg: test.pkg, name: split[1]}
				log.Printf("consolidating failed subtest %q into parent test %q", subTest.name, parentTest.name)
				failures[parentTest] = append(failures[parentTest], testEvents...)
				delete(failures, test)
			} else {
				__antithesis_instrumentation__.Notify(40795)
				log.Printf("failed parent test %q", test)
			}
		}
		__antithesis_instrumentation__.Notify(40790)

		var failedTestNames []scopedTest
		for name := range failures {
			__antithesis_instrumentation__.Notify(40796)
			failedTestNames = append(failedTestNames, name)
		}
		__antithesis_instrumentation__.Notify(40791)
		sort.Slice(failedTestNames, func(i, j int) bool {
			__antithesis_instrumentation__.Notify(40797)
			return fmt.Sprint(failedTestNames[i]) < fmt.Sprint(failedTestNames[j])
		})
		__antithesis_instrumentation__.Notify(40792)
		for _, test := range failedTestNames {
			__antithesis_instrumentation__.Notify(40798)
			testEvents := failures[test]
			var outputs []string
			for _, testEvent := range testEvents {
				__antithesis_instrumentation__.Notify(40800)
				outputs = append(outputs, testEvent.Output)
			}
			__antithesis_instrumentation__.Notify(40799)
			err := fileIssue(ctx, failure{
				title:       fmt.Sprintf("%s: %s failed", trimPkg(test.pkg), test.name),
				packageName: test.pkg,
				testName:    test.name,
				testMessage: strings.Join(outputs, ""),
			})
			if err != nil {
				__antithesis_instrumentation__.Notify(40801)
				return errors.Wrap(err, "failed to post issue")
			} else {
				__antithesis_instrumentation__.Notify(40802)
			}
		}
	}
	__antithesis_instrumentation__.Notify(40706)

	sort.Slice(slowPassEvents, func(i, j int) bool {
		__antithesis_instrumentation__.Notify(40803)
		return slowPassEvents[i].Elapsed > slowPassEvents[j].Elapsed
	})
	__antithesis_instrumentation__.Notify(40707)
	sort.Slice(slowFailEvents, func(i, j int) bool {
		__antithesis_instrumentation__.Notify(40804)
		return slowFailEvents[i].Elapsed > slowFailEvents[j].Elapsed
	})
	__antithesis_instrumentation__.Notify(40708)

	report := genSlowTestsReport(slowPassEvents, slowFailEvents)
	if err := writeSlowTestsReport(report); err != nil {
		__antithesis_instrumentation__.Notify(40805)
		log.Printf("failed to create slow tests report: %s", err)
	} else {
		__antithesis_instrumentation__.Notify(40806)
	}
	__antithesis_instrumentation__.Notify(40709)

	if timedOutCulprit.name != "" {
		__antithesis_instrumentation__.Notify(40807)
		slowest := slowFailEvents[0]
		if len(slowPassEvents) > 0 && func() bool {
			__antithesis_instrumentation__.Notify(40809)
			return slowPassEvents[0].Elapsed > slowest.Elapsed == true
		}() == true {
			__antithesis_instrumentation__.Notify(40810)
			slowest = slowPassEvents[0]
		} else {
			__antithesis_instrumentation__.Notify(40811)
		}
		__antithesis_instrumentation__.Notify(40808)
		if timedOutCulprit == scoped(slowest) {
			__antithesis_instrumentation__.Notify(40812)

			log.Printf("timeout culprit found: %s\n", timedOutCulprit.name)
			err := fileIssue(ctx, failure{
				title:       fmt.Sprintf("%s: %s timed out", trimPkg(timedOutCulprit.pkg), timedOutCulprit.name),
				packageName: timedOutCulprit.pkg,
				testName:    timedOutCulprit.name,
				testMessage: report,
			})
			if err != nil {
				__antithesis_instrumentation__.Notify(40813)
				return errors.Wrap(err, "failed to post issue")
			} else {
				__antithesis_instrumentation__.Notify(40814)
			}
		} else {
			__antithesis_instrumentation__.Notify(40815)
			log.Printf("timeout culprit not found\n")

			err := fileIssue(ctx, failure{
				title:       fmt.Sprintf("%s: package timed out", shortPkg()),
				packageName: maybeEnv(pkgEnv, "unknown"),
				testName:    unknown,
				testMessage: report,
			})
			if err != nil {
				__antithesis_instrumentation__.Notify(40816)
				return errors.Wrap(err, "failed to post issue")
			} else {
				__antithesis_instrumentation__.Notify(40817)
			}
		}
	} else {
		__antithesis_instrumentation__.Notify(40818)
	}
	__antithesis_instrumentation__.Notify(40710)

	return nil
}

func genSlowTestsReport(slowPassingTests, slowFailingTests []testEvent) string {
	__antithesis_instrumentation__.Notify(40819)
	var b strings.Builder
	b.WriteString("Slow failing tests:\n")
	for i, te := range slowFailingTests {
		__antithesis_instrumentation__.Notify(40824)
		if i == 20 {
			__antithesis_instrumentation__.Notify(40826)
			break
		} else {
			__antithesis_instrumentation__.Notify(40827)
		}
		__antithesis_instrumentation__.Notify(40825)
		fmt.Fprintf(&b, "%s - %.2fs\n", te.Test, te.Elapsed)
	}
	__antithesis_instrumentation__.Notify(40820)
	if len(slowFailingTests) == 0 {
		__antithesis_instrumentation__.Notify(40828)
		fmt.Fprint(&b, "<none>\n")
	} else {
		__antithesis_instrumentation__.Notify(40829)
	}
	__antithesis_instrumentation__.Notify(40821)

	b.WriteString("\nSlow passing tests:\n")
	for i, te := range slowPassingTests {
		__antithesis_instrumentation__.Notify(40830)
		if i == 20 {
			__antithesis_instrumentation__.Notify(40832)
			break
		} else {
			__antithesis_instrumentation__.Notify(40833)
		}
		__antithesis_instrumentation__.Notify(40831)
		fmt.Fprintf(&b, "%s - %.2fs\n", te.Test, te.Elapsed)
	}
	__antithesis_instrumentation__.Notify(40822)
	if len(slowPassingTests) == 0 {
		__antithesis_instrumentation__.Notify(40834)
		fmt.Fprint(&b, "<none>\n")
	} else {
		__antithesis_instrumentation__.Notify(40835)
	}
	__antithesis_instrumentation__.Notify(40823)
	return b.String()
}

func writeSlowTestsReport(report string) error {
	__antithesis_instrumentation__.Notify(40836)
	return ioutil.WriteFile("artifacts/slow-tests-report.txt", []byte(report), 0644)
}

func getFileLine(
	ctx context.Context, packageName, testName string,
) (_filename string, _linenum string, _ error) {
	__antithesis_instrumentation__.Notify(40837)

	subtests := strings.Split(testName, "/")
	testName = subtests[0]
	packageName = strings.TrimPrefix(packageName, "github.com/cockroachdb/cockroach/")
	cmd := exec.Command(`/bin/bash`, `-c`,
		fmt.Sprintf(`cd "$(git rev-parse --show-toplevel)" && git grep -n 'func %s(' '%s/*_test.go'`,
			testName, packageName))

	out, err := cmd.CombinedOutput()
	if err != nil {
		__antithesis_instrumentation__.Notify(40840)
		return "", "", errors.Wrapf(err, "couldn't find test %s in %s: %s\n",
			testName, packageName, string(out))
	} else {
		__antithesis_instrumentation__.Notify(40841)
	}
	__antithesis_instrumentation__.Notify(40838)
	re := regexp.MustCompile(`(.*):(.*):`)

	matches := re.FindSubmatch(out)
	if matches == nil {
		__antithesis_instrumentation__.Notify(40842)
		return "", "", errors.Errorf("couldn't find filename/line number for test %s in %s: %s",
			testName, packageName, string(out))
	} else {
		__antithesis_instrumentation__.Notify(40843)
	}
	__antithesis_instrumentation__.Notify(40839)
	return string(matches[1]), string(matches[2]), nil
}

func getOwner(ctx context.Context, packageName, testName string) (_teams []team.Team) {
	__antithesis_instrumentation__.Notify(40844)
	filename, _, err := getFileLine(ctx, packageName, testName)
	if err != nil {
		__antithesis_instrumentation__.Notify(40847)
		log.Printf("getting file:line for %s.%s: %s", packageName, testName, err)
		return nil
	} else {
		__antithesis_instrumentation__.Notify(40848)
	}
	__antithesis_instrumentation__.Notify(40845)
	co, err := codeowners.DefaultLoadCodeOwners()
	if err != nil {
		__antithesis_instrumentation__.Notify(40849)
		log.Printf("loading codeowners: %s", err)
		return nil
	} else {
		__antithesis_instrumentation__.Notify(40850)
	}
	__antithesis_instrumentation__.Notify(40846)
	return co.Match(filename)
}

func formatPebbleMetamorphicIssue(
	ctx context.Context, f failure,
) (issues.IssueFormatter, issues.PostRequest) {
	__antithesis_instrumentation__.Notify(40851)
	var repro string
	{
		__antithesis_instrumentation__.Notify(40853)
		const seedHeader = "===== SEED =====\n"
		i := strings.Index(f.testMessage, seedHeader)
		if i != -1 {
			__antithesis_instrumentation__.Notify(40854)
			s := f.testMessage[i+len(seedHeader):]
			s = strings.TrimSpace(s)
			s = strings.TrimSpace(s[:strings.Index(s, "\n")])
			repro = fmt.Sprintf("go test -mod=vendor -tags 'invariants' -exec 'stress -p 1' "+
				`-timeout 0 -test.v -run TestMeta$ ./internal/metamorphic -seed %s -ops "uniform:5000-10000"`, s)
		} else {
			__antithesis_instrumentation__.Notify(40855)
		}
	}
	__antithesis_instrumentation__.Notify(40852)
	return issues.UnitTestFormatter, issues.PostRequest{
		TestName:    f.testName,
		PackageName: f.packageName,
		Message:     f.testMessage,
		Artifacts:   "meta",
		HelpCommand: issues.ReproductionCommandFromString(repro),
		ExtraLabels: []string{"metamorphic-failure"},
	}
}
